# Соревнование

# Напишите программу, которая измеряет время, которое затрачивают на поиск линейный и бинарный поиски.
# Подайте ей на вход массивы длинной 1, 2, 4, 8, ... 2^n элементов.
# Определите количество элементов, начиная с которого бинарный поиск эффективнее.
# Время на сортировку массива для бинарного поиска не учитывать.

# Напишите тут ваш код
import time
import random


def linear_search(arr, target):
    for i in range(len(arr)):
        if arr[i] == target:
            return i
    return -1


def binary_search(arr, target):
    low = 0
    high = len(arr) - 1
    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1
    return -1


def generate_array(n):
    return sorted([random.randint(1, 2 ** 20) for _ in range(2 ** n)])


def measure_time(search_func, arr, target):
    start_time = time.time()
    search_func(arr, target)
    return time.time() - start_time


def find_threshold():
    threshold_found = False
    threshold = 0
    for n in range(21):  # 0..20
        size = 2 ** n
        arr = generate_array(n)
        target = arr[-1]  # Худший случай - ищем последний элемент

        # Измеряем время линейного поиска
        linear_time = measure_time(linear_search, arr, target)

        # Измеряем время бинарного поиска
        binary_time = measure_time(binary_search, arr, target)

        print(f"n = {n}, size = {size}")
        print(f"Линейный поиск: {linear_time:.8f} сек")
        print(f"Бинарный поиск: {binary_time:.8f} сек")
        print("---")

        # Проверяем, стал ли бинарный поиск быстрее
        if not threshold_found and binary_time < linear_time:
            threshold = size
            threshold_found = True

    return threshold


# Находим порог, начиная с которого бинарный поиск становится эффективнее
threshold = find_threshold()
print(f"Бинарный поиск становится эффективнее линейного начиная с {threshold} элементов")



'''
        Пояснения:
        
        Генерация массивов: Массивы генерируются длиной 2^n, где n от 0 до 20. Для бинарного поиска массив 
        предварительно сортируется (но время сортировки не учитывается, как требуется в задании).
        
        Линейный поиск: Проходит по всем элементам массива, пока не найдет искомый. В худшем случае 
        (когда элемента нет или он последний) время работы составляет O(n).
        
        Бинарный поиск: Работает за O(log n), но требует отсортированного массива. В программе массив генерируется 
        уже отсортированным.
        
        Измерение времени: Для каждого размера массива измеряется время работы обоих алгоритмов в худшем случае 
        (когда искомый элемент — последний в массиве).
        
        Определение порога: Программа находит минимальный размер массива, начиная с которого бинарный поиск 
        работает быстрее линейного.
        
        Примечание:
        На небольших массивах (n < 5-10) разница может быть незначительной или даже в пользу линейного поиска 
        из-за накладных расходов на организацию бинарного поиска.
        
        Результат зависит от конкретного железа и реализации Python, но в большинстве случаев бинарный поиск 
        начинает выигрывать при размерах массива порядка 10-100 элементов.
'''




# Лучший поиск

# Напишите программу которая выяснит, что какой способ поиска в массиве из 1000 элементов быстрее:
# Способ 1: 10 раз воспользоваться линейным поиском.
# Способ 2: отсортировать массив + 10 раз воспользоваться бинарным поиском.

# Напишите тут ваш код
import random
import time

# Генерация массива из 1000 случайных элементов
array = [random.randint(1, 10000) for _ in range(1000)]

# Функция линейного поиска
def linear_search(arr, target):
    for i in range(len(arr)):
        if arr[i] == target:
            return i
    return -1

# Функция бинарного поиска
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1

# Выбираем 10 случайных элементов для поиска
targets = [random.choice(array) for _ in range(10)]

# Способ 1: 10 линейных поисков в несортированном массиве
start_time = time.time()
for target in targets:
    linear_search(array, target)
linear_time = time.time() - start_time

# Способ 2: Сортировка массива + 10 бинарных поисков
start_time = time.time()
sorted_array = sorted(array)
for target in targets:
    binary_search(sorted_array, target)
binary_time = time.time() - start_time

# Вывод результатов
print(f"Время 10 линейных поисков: {linear_time:.6f} секунд")
print(f"Время сортировки + 10 бинарных поисков: {binary_time:.6f} секунд")

if linear_time < binary_time:
    print("Линейный поиск быстрее")
else:
    print("Бинарный поиск (включая сортировку) быстрее")


'''
        Пояснение:
        Генерация массива: создается массив из 1000 случайных чисел от 1 до 10 000.
        
        Линейный поиск: итерируется по массиву, пока не найдет целевой элемент.
        
        Бинарный поиск: работает только на отсортированном массиве, делит диапазон поиска пополам на каждой итерации.
        
        Измерение времени:
        
        Для линейного поиска: 10 раз ищем случайные элементы в исходном массиве.
        
        Для бинарного поиска: сначала сортируем массив, затем 10 раз ищем элементы.
        
        Вывод результатов: сравнивается общее время для обоих методов.
        
        Примечание:
        Если массив небольшой (например, 1000 элементов), линейный поиск может оказаться быстрее, 
        потому что сортировка требует дополнительного времени.
        
        Для больших массивов бинарный поиск (несмотря на начальную сортировку) будет выигрывать, так 
        как его сложность — O(log n), против O(n) у линейного.
'''