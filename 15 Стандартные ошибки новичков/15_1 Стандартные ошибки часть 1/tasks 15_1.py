# Параметры по умолчанию.

# Напишите 2 функции: def foo(bar=[]) и foo_correct(bar=None).
# Каждая функция принимает список и добавляет в него элемент "baz".
# Если список не передан, функция должна использовать новый пустой список.
# Покажите, как использование изменяемого объекта в качестве значения по умолчанию может привести к неожиданному поведению, и исправьте это (во второй функции).


# Напишите тут ваш код
def foo(bar=[]):
    bar.append('baz')
    return bar


def foo_correct(bar=None):
    if bar is None:
        bar = []
    bar.append('baz')
    return bar


# Проверка исправленной функции
print(foo_correct())  # Выводит: ['baz']
print(foo_correct())  # Выводит: ['baz']
print(foo_correct())  # Выводит: ['baz']

# Проверка с передачей списка
lst = [1, 2, 3]
print(foo_correct(lst))  # Выводит: [1, 2, 3, "baz"]
print(foo_correct(lst))  # Выводит: [1, 2, 3, "baz", "baz"]






# Неправильное указание параметров

# В примере приведен код, которые неправильно перехватывает несколько типов
# исключений одновременно.
# Напишите ниже исправленный вариант.

# Неправильный вариант: несколько исключений перехватываются неправильно
try:
    number = int(input("Введите число: "))
    result = 10 / number
except (ValueError, ZeroDivisionError):
    print("Произошла ошибка: вводите только числа кроме нуля.")

# Исправленный вариант: корректная обработка исключений

# Напишите тут ваш код
try:
    number = int(input("Введите число: "))
    result = 10 / number
except (ValueError, ZeroDivisionError) as e:
    print(f"Произошла ошибка: {e} вводите только числа кроме нуля.")