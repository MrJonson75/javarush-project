# Бинарное дерево

# Напишите функцию для вставки нового элемента в бинарное дерево поиска (BST).
# Функция должна принимать корневой узел дерева и значение нового элемента и
# возвращать обновленное дерево.

class TreeNode:
    def __init__(self, value=0, left=None, right=None):
        self.value = value
        self.left = left
        self.right = right


def insert_into_bst(root, value):
    if root is None:
        return TreeNode(value)

    if value < root.value:
        root.left = insert_into_bst(root.left, value)
    elif value > root.value:
        root.right = insert_into_bst(root.right, value)
    # Если значение уже существует в дереве, ничего не делаем

    return root



'''
        Объяснение:
        Проверка на пустое дерево: Если root равен None, создаем новый узел с заданным значением и 
        возвращаем его.
        
        Сравнение значений:
        
        Если value меньше значения текущего узла (root.value), рекурсивно вызываем функцию 
        для левого поддерева.
        
        Если value больше значения текущего узла, рекурсивно вызываем функцию для правого поддерева.
        
        Обработка дубликатов: Если value уже существует в дереве (равно root.value), ничего не 
        делаем (по правилам BST дубликаты обычно не добавляются).
        
        Возврат обновленного дерева: В конце возвращаем корневой узел (возможно, обновленный 
        после рекурсивных вызовов).
        
'''


# Поиск элемента в бинарном дереве

# Напишите функцию для поиска элемента в бинарном дереве поиска (BST).
# Функция должна принимать корневой узел дерева и значение искомого элемента
# и возвращать узел, содержащий искомое значение, или None, если элемент не найден.

class TreeNode:
    def __init__(self, value=0, left=None, right=None):
        self.value = value
        self.left = left
        self.right = right


def search_bst(root: TreeNode, val: int) -> TreeNode:
    if root is None or root.value == val:
        return root
    if val < root.value:
        return search_bst(root.left, val)
    else:
        return search_bst(root.right, val)



'''
        Объяснение:
        Базовый случай: Если root равен None (значит, мы дошли до конца ветки и не нашли элемент) или 
        значение текущего узла равно искомому (root.value == val), возвращаем текущий узел (или None).
        
        Рекурсивный случай:
        
        Если искомое значение val меньше значения текущего узла (val < root.value), рекурсивно ищем в 
        левом поддереве (search_bst(root.left, val)).
        
        Если искомое значение val больше значения текущего узла, рекурсивно ищем в правом поддереве 
        (search_bst(root.right, val)).
        
        Эта функция соответствует всем требованиям:
        
        Принимает корень дерева (root) и искомое значение (val).
        
        Использует рекурсивный метод для поиска.
        
        Сравнивает значение узла с искомым значением и решает, в какое поддерево идти.
        
        Возвращает узел, если значение найдено, или None, если значение отсутствует в дереве.
'''