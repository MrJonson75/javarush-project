# Разложение

# Найти количество способов разложить заданное число n на слагаемые.
# Подсказка: Если текущее слагаемое меньше или равно целевой сумме,
# количество способов = количество способов без текущего слагаемого + количество способов с текущим слагаемым.


def number_of_ways(n):
    def count_partitions(target, max_num):
        # Базовые случаи рекурсии
        if target == 0:
            return 1  # Нашли одно разложение
        if max_num == 0:
            return 0  # Невозможно разложить

        # Если текущее максимальное слагаемое больше целевого числа,
        # пробуем меньшее слагаемое
        if max_num > target:
            return count_partitions(target, max_num - 1)

        # Рекурсивно считаем разложения:
        # 1. Содержащие max_num как слагаемое
        # 2. Не содержащие max_num как слагаемое
        return count_partitions(target - max_num, max_num) + count_partitions(target, max_num - 1)

    return count_partitions(n, n - 1)

n = int(input("Введите число n: "))
print("Количество способов разложить число", n, "на слагаемые:", number_of_ways(n))




# Количество способов

# Найти количество способов набора заданной суммы S с помощью набора монет с различными номиналами.
# Подсказка 1: Если текущая сумма меньше номинала монеты,
# количество способов равно количеству способов набора суммы без использования текущей монеты.
# Подсказка 2: Если текущая сумма больше или равна номиналу монеты,
# количество способов = количество способов без использования текущей монеты + количество способов с использованием текущей монеты.


def count_ways(coins, S):
    # Создаем массив для хранения количества способов для каждой суммы от 0 до S
    dp = [0] * (S + 1)
    dp[0] = 1  # Нулевая сумма может быть набрана одним способом - не используя монеты

    for coin in coins:
        for amount in range(coin, S + 1):
            # Для каждой суммы, начиная с номинала монеты, обновляем количество способов
            dp[amount] += dp[amount - coin]

    return dp[S]

# Пример использования
coins = [1, 2, 5]
S = 11
print(count_ways(coins, S))  # Вывод: количество способов набрать сумму 11