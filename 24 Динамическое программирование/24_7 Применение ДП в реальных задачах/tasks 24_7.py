# Возрастающая подпоследовательность.

# Дан массив чисел arr. Найдите длину наибольшей возрастающей подпоследовательности. Обратите внимание, что элементы подпоследовательности могут идти не подряд.
# Подсказка: Используйте массив dp, где dp[i] будет представлять длину наибольшей возрастающей подпоследовательности,
# заканчивающейся на элементе arr[i].


def length_of_lis(arr):
    # Если массив пуст, длина LIS равна 0
    if not arr:
        return 0

    # Длина входного массива
    n = len(arr)

    # Создаем массив dp, где dp[i] будет хранить длину наибольшей возрастающей
    # подпоследовательности, заканчивающейся на элементе arr[i]
    # Инициализируем все элементы dp значением 1, так как минимальная
    # подпоследовательность состоит из самого элемента
    dp = [1] * n

    # Проходим по всем элементам массива, начиная со второго
    for i in range(1, n):
        # Для текущего элемента arr[i] проверяем все предыдущие элементы arr[j]
        for j in range(i):
            # Если предыдущий элемент меньше текущего (arr[j] < arr[i]),
            # значит мы можем потенциально увеличить подпоследовательность
            if arr[j] < arr[i]:
                # Обновляем dp[i] только если новая подпоследовательность (dp[j] + 1)
                # окажется длиннее текущего значения dp[i]
                dp[i] = max(dp[i], dp[j] + 1)

    # Находим максимальное значение в массиве dp,
    # которое и будет длиной наибольшей возрастающей подпоследовательности
    return max(dp)


# Пример использования
arr = [10, 9, 2, 5, 3, 7, 101, 18]
print(length_of_lis(arr))  # Output: 4 (например, [2, 5, 7, 101] или [2, 5, 7, 18])

# Пример использования
arr = [10, 9, 2, 5, 3, 7, 101, 18]
print(length_of_lis(arr))  # Output: 4 (2,5,7,101 или 2,5,7,18)




# Путь в графе

# У вас есть граф, представленный в виде матрицы смежности, где graph[i][j] обозначает стоимость пути от города i к городу j.
# Найдите минимальный путь, который начинается и заканчивается в одном и том же городе и проходит через все города ровно один раз
# Подсказка: Используйте динамическое программирование для хранения промежуточных результатов.

INF = float('inf')


def tsp(graph):
    # Количество городов (вершин графа)
    n = len(graph)

    # Создаем таблицу для мемоизации:
    # dp[mask][i] будет хранить минимальную стоимость пути,
    # который посещает все города в маске 'mask' и заканчивается в городе 'i'
    # Инициализируем таблицу значениями INF (бесконечность)
    dp = [[INF] * n for _ in range(1 << n)]

    # Базовый случай: путь из города в себя же (маска содержит только один город)
    for i in range(n):
        dp[1 << i][i] = graph[i][i]  # Обычно graph[i][i] = 0

    # Перебираем все возможные маски (комбинации посещенных городов)
    for mask in range(1 << n):
        # Для каждой маски проверяем все возможные последние города
        for last in range(n):
            # Пропускаем, если город 'last' не посещен в текущей маске
            if not (mask & (1 << last)):
                continue

            # Пытаемся обновить dp[mask][last], рассматривая предыдущий город
            prev_mask = mask ^ (1 << last)
            if prev_mask == 0:
                continue  # Нельзя иметь пустую маску с посещенным городом

            for prev in range(n):
                if prev_mask & (1 << prev):
                    # Обновляем стоимость: стоимость до предыдущего города + переход
                    dp[mask][last] = min(dp[mask][last],
                                         dp[prev_mask][prev] + graph[prev][last])

    # Ищем минимальный гамильтонов цикл
    min_cost = INF
    full_mask = (1 << n) - 1  # Маска, где все города посещены

    # Перебираем все возможные конечные города для полного цикла
    for last in range(n):
        # Находим город, из которого можно вернуться в начальный
        for start in range(n):
            if start != last and graph[last][start] != INF:
                # Полная стоимость цикла: стоимость пути + возврат в начальный город
                total_cost = dp[full_mask][last] + graph[last][start]
                if total_cost < min_cost:
                    min_cost = total_cost

    return min_cost if min_cost != INF else -1  # Возвращаем -1, если путь не существует


# Пример использования
graph = [
    [0, 10, 15, 20],
    [10, 0, 35, 25],
    [15, 35, 0, 30],
    [20, 25, 30, 0]
]
print(tsp(graph))