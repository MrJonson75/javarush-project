# Максимальный поток в сети

# Есть нефтепровод (граф) заданный матрицей смежности.
# Число в матрице - это пропускная способность нефтепровода между двумя городами.
# Нужно подсчитать сколько максимально можно прокачать нефти между двумя вершинами.
# В теории графов: Найти максимальный поток в сети с источником и стоком.

# Подсказка 1:
# Используйте графовые алгоритмы, такие как алгоритм Форда-Фалкерсона, комбинированные с методами поиска в ширину (BFS) и в глубину (DFS).
# Подсказка 2:
# 1) Используйте BFS для поиска путей с доступным потоком.
# 2) Повторяйте процесс, пока существуют пути с доступным потоком.
# 3) Обновляйте резидуальные графы для учёта использованных потоков.


from collections import deque


def bfs(residual_graph, source, sink, parent):
    """
    Поиск в ширину (BFS) для нахождения увеличивающего пути в остаточной сети.

    Args:
        residual_graph: Остаточная сеть (матрица пропускных способностей)
        source: Исток (начальная вершина)
        sink: Сток (конечная вершина)
        parent: Массив для хранения пути

    Returns:
        True, если существует путь от истока к стоку, иначе False
    """
    # Инициализация: все вершины не посещены
    visited = [False] * len(residual_graph)
    queue = deque([source])  # Очередь для BFS
    visited[source] = True  # Исток посещен

    while queue:
        u = queue.popleft()  # Берем первую вершину из очереди

        # Проверяем всех соседей вершины u
        for ind, val in enumerate(residual_graph[u]):
            # Если сосед не посещен и остаточная пропускная способность > 0
            if not visited[ind] and val > 0:
                queue.append(ind)  # Добавляем в очередь
                visited[ind] = True  # Помечаем как посещенную
                parent[ind] = u  # Запоминаем предка
                # Если дошли до стока - путь найден
                if ind == sink:
                    return True
    return False  # Путь не найден


def edmonds_karp(capacity_matrix, source, sink):
    """
    Алгоритм Эдмондса-Карпа для нахождения максимального потока.

    Args:
        capacity_matrix: Матрица пропускных способностей
        source: Исток (начальная вершина)
        sink: Сток (конечная вершина)

    Returns:
        Максимальный поток от истока к стоку
    """
    # Создаем остаточную сеть (копируем исходную матрицу)
    residual_graph = [row[:] for row in capacity_matrix]
    max_flow = 0  # Изначально поток нулевой
    parent = [-1] * len(residual_graph)  # Массив для хранения пути

    # Пока существует увеличивающий путь в остаточной сети
    while bfs(residual_graph, source, sink, parent):
        # Находим минимальную пропускную способность на пути
        path_flow = float('Inf')
        s = sink
        while s != source:
            path_flow = min(path_flow, residual_graph[parent[s]][s])
            s = parent[s]

        # Добавляем найденный поток к общему потоку
        max_flow += path_flow

        # Обновляем остаточные пропускные способности
        v = sink
        while v != source:
            u = parent[v]
            residual_graph[u][v] -= path_flow  # Уменьшаем прямую пропускную способность
            residual_graph[v][u] += path_flow  # Увеличиваем обратную пропускную способность
            v = parent[v]

    return max_flow


# Пример использования
if __name__ == "__main__":
    # Матрица пропускных способностей (capacity_matrix[i][j] - пропускная способность от i к j)
    capacity_matrix = [
        [0, 16, 13, 0, 0, 0],  # 0 - исток
        [0, 0, 10, 12, 0, 0],  # 1
        [0, 4, 0, 0, 14, 0],  # 2
        [0, 0, 9, 0, 0, 20],  # 3
        [0, 0, 0, 7, 0, 4],  # 4
        [0, 0, 0, 0, 0, 0]  # 5 - сток
    ]
    source = 0  # Исток
    sink = 5  # Сток

    print("Максимальный поток:", edmonds_karp(capacity_matrix, source, sink))






# У вас есть набор предметов на складе заданный массивом кортежей (вес, цена, количество).

# Вам нужно перевести их на другой склад, но каждого предмета можно взять не более чем k.
# Найти набор предметов, максимизирующий ценность.
# Подсказка 1:
# Используйте динамическое программирование для основной задачи о рюкзаке и жадные алгоритмы для удовлетворения дополнительных ограничений.
# Подсказка 2:
# 1) Создайте таблицу для хранения максимальных ценностей для каждого веса.
# 2) Обновляйте таблицу, учитывая ограничения на количество каждого предмета.
# 3) Используйте жадные методы для удовлетворения дополнительных ограничений, если необходимо.

def knapsack_with_restrictions(items, max_weight, k):
    """
    Решает задачу о рюкзаке с ограничением на количество каждого предмета.

    Args:
        items: Список кортежей (вес, ценность, количество) для каждого предмета
        max_weight: Максимальный общий вес рюкзака
        k: Максимальное количество каждого предмета, которое можно взять

    Returns:
        Максимальная ценность, которую можно унести в рюкзаке
    """
    # Инициализация таблицы динамического программирования
    # dp[w] будет хранить максимальную ценность для веса w
    dp = [0] * (max_weight + 1)

    for weight, value, count in items:
        # Ограничиваем количество предмета минимальным между доступным количеством и k
        max_take = min(count, k)

        # Создаем временную копию текущего состояния dp
        temp_dp = dp.copy()

        # Перебираем все возможные количества для текущего предмета (от 1 до max_take)
        for take in range(1, max_take + 1):
            current_weight = take * weight
            current_value = take * value

            # Обновляем таблицу для всех возможных весов
            for w in range(max_weight, current_weight - 1, -1):
                if temp_dp[w - current_weight] + current_value > dp[w]:
                    dp[w] = temp_dp[w - current_weight] + current_value

    return dp[max_weight]


# Пример использования
if __name__ == "__main__":
    items = [
        (2, 3, 4),  # Вес 2, ценность 3, количество 4
        (3, 4, 3),  # Вес 3, ценность 4, количество 3
        (4, 5, 2)  # Вес 4, ценность 5, количество 2
    ]
    max_weight = 10  # Максимальный вес рюкзака
    k = 2  # Максимальное количество каждого предмета

    max_value = knapsack_with_restrictions(items, max_weight, k)
    print(f"Максимальная ценность: {max_value}")  # Ожидаемый вывод: 13